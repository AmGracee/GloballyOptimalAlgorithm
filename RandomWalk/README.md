## 1. 关于全局最优化求解

全局最优化是一个非常复杂的问题，目前还没有一个通用的办法可以对任意复杂函数求解全局最优值。上一篇文章讲解了一个求解局部极小值的方法——**梯度下降法**。这种方法对于求解精度不高的情况是实用的，可以用局部极小值近似替代全局最小值点。但是当要求精确求解全局最小值时，梯度下降法就不适用了，需要采用其他的办法求解。常见的求解全局最优的办法有拉格朗日法、线性规划法、以及一些人工智能算法比如遗传算法、粒子群算法、模拟退火算法等。而今天要讲的是一个操作简单但是不易陷入局部极小值的方法：**随机游走算法**。

## 2. 随机游走算法操作步骤

设$f(x)$是一个含有$n$个变量的多元函数,$x=(x_1,x_2,...,x_n)$,为n维向量。

1. 给定初始迭代点x，初次行走步长λ，控制精度ϵ(ϵ是一个非常小的正数，用于控制结束算法)。

2. 给定迭代控制次数N，k为当前迭代次数，置k=1。

3. 当 k<N时，随机生成一个(−1,1)之间的n维向量

   $u=(u_1,u_2,⋯,u_n),(−1<u_i<1,i=1,2,⋯,n)$，并将其标准化得到

   $u^.=\frac{u}{\sqrt{\sum_{i=1}^{n}{u_i^2}}}$. 令$x_1=x+λu^.$.，完成第一步游走。

4. 计算函数值，如果 $f(x_1)<f(x)$，即找到了一个比初始值好的点，那么k重新置为1，将$x_1$变为x，回到第2步；否则k=k+1，回到第3步。

5. 如果连续N次都找不到更优的值，则认为，最优解就在以当前最优解为中心，当前步长为半径的N维球内(如果是三维，则刚好是空间中的球体)。此时，如果λ<ϵ，则结束算法；否则，令$λ=λ_2$，回到第1步，开始新一轮游走。

## 3.随机游走的代码实现(使用Python)

这里使用的测试函数为$f(r)=\frac{sin(r)}{r}+1,r=\sqrt{(x−50)^2+(y−50)^2+e},0≤x,y≤100$,求$f(r)$的最大值。该函数是一个多峰函数，在(50,50)处取得全局最大值1.1512，第二最大值在其全局最大值附近，采用一般的优化方法很容易陷入局部极大值点。这里是求解函数的最大值问题，可以将其转化为求目标函数的相反数的最小值问题。具体代码如下：

代码V1是最初版本，接下来是改进版本

## 4.改进的随机游走算法

改进前的版本对初始值很敏感，经过迭代后，初始值离最优解越远，会走得距离最优解越来越远。
因此，将x来一个标准化。
即将原来是产生一个随机向量u，现在则是产生n个随机向量u1,u2,⋯,un，n是给定的一个正整数。将n个ui(i=1,2,⋯,n)标准化得到u′1,u′2,⋯,u′n，利用公式xi=x+λu′i,令min{x1,x2,⋯,xn}替换原来的x1，其他步骤保持不变。通过这种方式改进之后，随机游走算法的寻优能力大大提高，而且对于初始值的依赖程度也降低了


